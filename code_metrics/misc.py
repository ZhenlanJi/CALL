# 实现 
# 1. black test pep8
# 2. 


import os
import json
from subprocess import PIPE, Popen
import subprocess
from tqdm import tqdm
from multiprocessing.pool import Pool
import shutil
import re
from tree_sitter import Language, Parser

def semgrep_call(code,lanuage='python'):
    temp_file = '../temp/black_temp.py'
    temp_log = '../temp/temp_result.json'
    with open(temp_file,'w',encoding='utf-8') as f2:
        f2.write(code)
    result_num = 0
    try:
    
        cmd = 'python -m semgrep --config "p/python" ../temp/black_temp.py --json -o ../temp/temp_result.json > semgrep.log'
        result = subprocess.run(cmd, shell=True, check=True, stdout=subprocess.PIPE)
        with open(temp_log,'r',encoding='utf-8') as f3:
            changelog = json.load(f3)
            result_num = len(changelog['results'])
            #     changed = changelog.count("@@")//2
            print('总共发现error{}'.format(result_num))

    except subprocess.CalledProcessError as e:
        # print(e)
        pass

    return result_num

def sitter_call(code,lanuage='python'):
    PY_LANGUAGE = Language('../build/my-languages.so', 'python')
    parser = Parser()
    parser.set_language(PY_LANGUAGE)
    tree = parser.parse(bytes(code, "utf8"))
    root_node = tree.root_node
    treecontent = root_node.sexp()
    has_error = False
    try:
        if root_node.has_error:
            # print('error!')
            has_error = True
    except:
        pass
    return has_error



def black_call(code,lanuage='python'):
    temp_file = '../temp/black_temp.py'

    with open(temp_file,'w',encoding='utf-8') as f2:
        f2.write(code)
    changed = 0
    try:
    
        cmd = 'black ../temp/black_temp.py --diff > ../temp/black.log'
        result = subprocess.run(cmd, shell=True, check=True, stdout=subprocess.PIPE)
        with open('../temp/black.log','r',encoding='utf-8') as f3:
            changelog = f3.read()
            # 统计有多少修改
            changed = changelog.count("@@")//2
            # print('pep8总共修改{}'.format(changed))

    except subprocess.CalledProcessError as e:
        # print(e)
        pass

    return changed


# input: code(str)
# output: (sitter_result (bool), black_result (num), semgrep_result (num) )
# v2_output: additional_prompt
def qualitycheck(code,Language='python'):
    p = sitter_call(code)
    k = black_call(code)
    j = semgrep_call(code)
    sitter_prompt = 'The code contains syntax errors' if p else 'The code does not contain syntax errors'
    if k!= 0 :
        black_prompt = 'The code does not comply with the PEP8 specification in '+str(k) +' places'
    else:
        black_prompt = 'The code comply with the PEP8 specification.'
    if j!=0:
        semgrep_prompt = 'The code has '+ str(j) +' potential security bug.'
    else:
        semgrep_prompt = 'No potential bugs are found.'
    # prompt_init = f'[Additional information from external tools] Below are the results generated by external tools used to evaluate the code: \n[PL parser Treesitter] {sitter_prompt}.\n[PL Code Formatter] {black_prompt}.\n[PL code analysis tool semgrep] {semgrep_prompt}'
    prompt_init = f'Below are the results generated by external tools used to evaluate the code: \n[PL parser Treesitter] {sitter_prompt}.\n[PL Code Formatter] {black_prompt}.\n[PL code analysis tool semgrep] {semgrep_prompt}'
    return prompt_init


def test1():
    code = '''def longest_common_subsequence(s1, s2):\n    # Create a matrix to store the lengths of common subsequences\n    matrix = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n\n    # Iterate through the strings and fill the matrix\n    for i in range(len(s1) - 1, -1, -1):\n        for j in range(len(s2) - 1, -1, -1):\n            if s1[i] == s2[j]:\n                matrix[i][j] = matrix[i + 1][j + 1] + 1\n            else:\n                matrix[i][j] = max(matrix[i + 1][j], matrix[i][j + 1])\n\n    # Reconstruct the longest common subsequence from the matrix\n    result = []\n    i, j = 0, 0\n    while i < len(s1) and j < len(s2):\n        if s1[i] == s2[j]:\n            result.append(s1[i])\n            i += 1\n            j += 1\n        elif matrix[i + 1][j] > matrix[i][j + 1]:\n            i += 1\n        else:\n            j += 1\n\n    return ''.join(result)\n\n# Example usage:\ns1 = \"ABCDGH\"\ns2 = \"AEDFHR\"\nprint(longest_common_subsequence(s1, s2))  # Output: \"ADH\"\n'''
    # k = black_call(code)
    # # print(k)
    # p = sitter_call(code)
    # print(p)
    # j = semgrep_call(code)
    # print(j)
    res = qualitycheck(code)
    print('--------------')
    print(res)


def main():
    test1()

if __name__ == '__main__':
    main()
